<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Viewport | Demo</title>
	<script type="text/javascript" src="../vendors/threejs/three.js"></script>
	<script type="text/javascript" src="../vendors/threejs/OrbitControls.js"></script>
	<script type="text/javascript" src="../vendors/dat.gui.min.js"></script>
	<style type="text/css">
		html, body {
		  margin: 0;
		  height: 100%;
		}
		#c,
		#c1 {
		top: 0;
		left: 0;
		  width: 100%;
		  height: 100%;
		  display: block;
		  position: absolute;
		}
		#c1 {
			z-index: 5;
			background:transparent;
		}
	</style>	
</head>
<body>
	<canvas id="c"></canvas>
	<canvas id="c1"></canvas>
	<script type="text/javascript" src="../js/app.js"></script>
	<script type="text/javascript" src="../js/gui.js"></script>
	<script type="text/javascript" src="../js/util.js"></script>
	<script>		
		let app;
		Promise.resolve(new App(window.innerWidth, window.innerHeight, document.querySelector( '#c' )))
		.then(newApp=>{
			app = newApp;				
			
			const fov = 75,
				aspect = window.innerWidth / window.innerHeight,
				near = 0.1,
				far = 10000;
									
			let camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
			app.setCamera(camera);
			
			const controls = new THREE.OrbitControls(camera, app.renderer.domElement);
			controls.target.set(0, 5, 0);
			controls.update();

			app.scene.background = new THREE.Color( 0x443333 );
			//app.scene.fog = new THREE.Fog( 0x443333, 200, 1000 );
			//app.scene.background.set(0xff0ff000);
			
			const renderer = app.renderer;
			const scene = app.scene;
			const canvas = renderer.domElement;
		    
			app.addDefault();
			
			  {
				  
				  let axesHelper =  new THREE.AxesHelper(50);
				  app.add(axesHelper);
				  
				  const {center, size} = app.getBox();
				  let maxLen = Math.max(size.x, Math.max(size.y, size.z)),
						distance = maxLen / (2 * mj.tanHalf(fov));
				
				   console.log('data info---', size, center, distance);
									
					//camera.position.set(center.x, center.y, center.z - distance);
					camera.position.set(center.x, center.y, center.z - distance);
					camera.position.z *= Math.sqrt(3);
					camera.lookAt(center.x,  center.y, center.z);
					
			  }
			  
			  function toScreenXY(position) {
					let pos = position.clone();
					let projScreenMat = new THREE.Matrix4();
					projScreenMat.multiply(camera.projectionMatrix, camera.matrixWorldInverse);
					projScreenMat.multiplyVector3(pos);
					
					let el = renderer.domElement,
						offset = screenOffset(renderer.domElement);
					return {
						x: (pos.x + 1) * el.width / 2 + offset.left,
						y: (-pos.y+1) * el.height / 2 + offset.top
					};					
			  }
			  function screenOffset(el) {
				  let pos = new Object();
				  pos.left = pos.top = 0;
				  if (el.offsetParent) {
					  do {
						  pos.left += el.offsetLeft;
						  pos.topp += el.offsetTop;						  
					  } while(el = el.offsetParent);
				  }
				  return pos;
			  }
			  let isChange = true, cpos = camera.position.clone();
			  function eq(x, y) {
				  return Math.abs(x-y) < 1e-5;
			  }
			  function printInfo() {
				  let p0 = new THREE.Vector3(0,0,0),
				  	p1 = new THREE.Vector3(1,1,1);
				  
				  let s0 = toScreenXY(p0),
				  	s1 = toScreenXY(p1);
				  console.log('--', s0.x-s1.x, s0.y-s1.y, s0, s1);
			  }
			  
			  renderer.domElement.addEventListener('wheel', (event)=>{
				  console.log('--------22');
				  printInfo();
			  }, false);
			  
			app.render((delta)=>{
			  // render
			  
// 			  printInfo();
			  
		      renderer.render(scene, camera);
		
			}, ()=>{
				// resize 
				app.updateSize(app.fullWidth, app.fullHeight);
			});			
			
		});
	</script>
</body>
</html>
