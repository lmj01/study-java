<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script type="text/javascript" src="../vendors/threejs/three.js"></script>
	<script type="text/javascript" src="../vendors/threejs/TrackballControls.js"></script>
	<script type="text/javascript" src="../vendors/threejs/OrbitControls.js"></script>
	<script type="text/javascript" src="../vendors/threejs/PLYLoader.js"></script>
	<script type="text/javascript" src="../vendors/threejs/GLTFLoader.js"></script>
	<script type="text/javascript" src="../vendors/dat.gui.min.js"></script>
	<script type="text/javascript" src="../vendors/signals.min.js"></script>	
	<style>
		html, body {
		  margin: 0;
		  height: 100%;
		}
		canvas {
		  width: 100%;
		  height: 100%;
		  display: block;
		  position: absolute;
		}    
	</style>
</head>
<body>
    <canvas id="c"></canvas>
    <script type="text/javascript" src="../js/app.js"></script>
    <script type="text/javascript" src="../js/gui.js"></script>s
	<script type="text/javascript" src="../js/util.js"></script>
    <script>
	    let app;
		Promise.resolve(new App(window.innerWidth, window.innerHeight, document.querySelector( '#c' )))
		.then(newApp=>{
			app = newApp;				
			const { renderer, scene, fullWidth, fullHeight } = app;
			const canvas = renderer.domElement;
			renderer.shadowMap.enabled = true;
			
			let target = new THREE.Vector3();						
			let size = 100, fov = 45.0, aspect = window.innerWidth/window.innerHeight,
				near = 0.1, far = 10000.0;
			let camera = 
// 				new THREE.PerspectiveCamera(fov, aspect, near, far);
				new THREE.OrthographicCamera(-fullWidth/2, fullWidth/2, fullHeight/2, -fullHeight/2	, near, far);
			camera.position.z = 90;
			app.setCamera(camera);
			
			scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );
			
// 			let spotLight = new THREE.SpotLight(0xffffbb, 2);
// 			spotLight.position.set(20, 0, 200);
// 			spotLight.position.multiplyScalar(100);
			
// 			scene.add(spotLight);
			
// 			spotLight.castShadow = true;
			
// 			spotLight.shadow.mapSize.width = 2048;
// 			spotLight.shadow.mapSize.height = 2048;
// 			spotLight.shadow.camera.near = 200;
// 			spotLight.shadow.camera.far = 1500;
// 			spotLight.shadow.camera.fov = fov;
// 			spotLight.shadow.bias = -0.005;
			
			
			let imgInfo = [
				['gumWithUv.png','gumWithUvNormal.png', 'gumWithUv.ply'],
				['halfuv.png', 'halfuvNormal.png', 'half.ply'],
				['uv.png', 'uvNormal.png', 'lower.ply'],
				['uv1.png', 'uvNormal1.png', 'gum4part.ply'], // 3
				['uv2.png', 'uvNormal1.png', 'gum4part.ply'], // 4
			];
			let mInfo = imgInfo[4];
			let mapHeight = new THREE.TextureLoader().load('../models/LeePerrySmith/Infinite-Level_02_Disp_NoSmoothUV-4096.jpg');
			let mapSpecular = new THREE.TextureLoader().load('../models/gum/uvSpecular.png');
			let mapTex = new THREE.TextureLoader().load('../models/gum/' + mInfo[0]),
				mapNormal = new THREE.TextureLoader().load('../models/gum/' + mInfo[1]);
			let headMaterial = new THREE.MeshPhongMaterial({ 
				color: 0x552811,
				specular: 0x222222,
				shininess: 25,
				bumpMap: mapHeight,
				bumpScale: 12 
			});
			let gumMaterial = new THREE.MeshPhongMaterial({
				map:mapTex,
				specular: 0x222222,
				specularMap: mapSpecular,
				shininess: 25,		
				bumpMap: mapNormal,
				bumpScale: 1,
			});
			
			function updateOrthoCamera(_camera, _control) {
				if (_control) {
					target = _control.target;	
				} else {
					target = new THREE.Vector3();
				}				
				let distance = _camera.position.distanceTo(target);
				let aspect = fullWidth / fullHeight;
				camera.left = distance * aspect / -2;
				camera.right = distance * aspect / 2;
				camera.top = distance / 2;
				camera.bottom = distance / -2;
				camera.updateProjectionMatrix();
			}
			
			let orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
			orbitControls.maxDistance = 1000;
			orbitControls.update();
			app.setControl(orbitControls);
						
// 			let trackballControls = new THREE.TrackballControls(camera, renderer.domElement);
// 			trackballControls.rotateSpeed = 2.0;
// 			trackballControls.zoomSpeed = 2;
// 			trackballControls.panSpeed = 2;
// 			trackballControls.noZoom = false;
// 			trackballControls.noPan = false;
// 			trackballControls.staticMoving = true;
// 			trackballControls.dynamicDampingFactor = 0.3;
// 			trackballControls.keys = [ 65, 83, 68 ];
// 			trackballControls.addEventListener( 'change', function () {
// // 				app.renderFrame();
// 			} );
// 			trackballControls.target.copy(target);
// 			if (!camera.isPerspectiveCamera) {
// 				trackballControls.maxDistance = 7500;
// 				trackballControls.minDistance = 0.1;
// 				trackballControls.addEventListener( 'end', function () {
// 					//updateOrthoCamera(camera,trackballControls);
// // 					app.renderFrame();
// 				});
// 			}
// 			app.setControl(trackballControls);			
						
			let ambientLight = new THREE.AmbientLight(0xe8d3d3, 0.3), // 0.2
				directionLight = new THREE.DirectionalLight(0xffffff, 1.0),
				directionLight2 = new THREE.DirectionalLight(0xffffff, 1.0),
				directionLight3 = new THREE.DirectionalLight(0xffffff, 1.0),
				directionLight4 = new THREE.DirectionalLight(0xffffff, 1.0),
				pointLight1 = new THREE.PointLight(0xffffff, 1, 100),
				pointLight2 = new THREE.PointLight(0xffffff, 1, 100),
				pointLight3 = new THREE.PointLight(0xffffff, 1, 100),
				pointLight4 = new THREE.PointLight(0xffffff, 1, 100),
				fog = new THREE.Fog(0x3f7b9d, 0, 60),
				diffuseColor = new THREE.Color(),
				specularColor = new THREE.Color();
			
			let dlTargetObject = new THREE.Object3D();
			scene.add(dlTargetObject);
			directionLight.target = dlTargetObject;
			scene.add(ambientLight);
			let lightDistance = 100;
			scene.add(directionLight); directionLight.position.set(0, 0, lightDistance * 100);
			scene.add(directionLight2); directionLight2.position.set(0, 0, -lightDistance * 100);
// 			scene.add(directionLight3); directionLight3.position.set(lightDistance, 0, 0);
// 			scene.add(directionLight4); directionLight4.position.set(-lightDistance, 0, 0);
// 			scene.add(pointLight1); pointLight1.position.set(0, 0, -lightDistance);
// 			scene.add(pointLight2); pointLight2.position.set(0, 0, lightDistance);
// 			scene.add(pointLight3); pointLight2.position.set(0, 100,0);
// 			scene.add(pointLight4); pointLight2.position.set(0, 0, 100);
			
			//scene.background = new THREE.Color( 0x443333 ); // 	0xffffff
			let scale = 1, mesh = null;
			if (true) {
				new THREE.PLYLoader().load('../models/gum/' + mInfo[2], function(geo) {
					let gum = new THREE.Mesh(geo, gumMaterial);
					gum.name = 'tset';
					gum.rotation.x -= Math.PI/2;
					//gum.position.y += 30;
					gum.castShadow = true;
					gum.receiveShadow = true;
					updateOrthoCamera(camera, app.control);
					scene.add(gum);
				});
			}
			if (false) {
	            new THREE.GLTFLoader().load('../models/LeePerrySmith/LeePerrySmith.glb', function(gltf) {
	            	
// 	            	let scale = 1, 
	            	mesh = new THREE.Mesh(gltf.scene.children[0].geometry, headMaterial);
// 	                mesh.position.y = -50;	                
// 	                mesh.scale.set(scale, scale, scale);
	            
					mesh.castShadow = true;
	                mesh.receiveShadow = true;
	            	
	                scene.add(mesh);
	                
	                app.updateCameraType(camera, "back", fov);	                
	                updateOrthoCamera(camera, app.control);
	                app.renderFrame();
	            });
	        }
			
		    let axesHelper =  new THREE.AxesHelper(10);		    
			app.add(axesHelper);
			
			const gui = new dat.GUI();	
			let option = {
				side: "front",
				
				// scene
				background: '#e0cdcd',
				ambient: ambientLight.color.getHex(),
				hasFog: false,
				fog: fog.color.getHex(),
				
				// mesh material
				transparent: false,
				opacity: 1,
				depthTest: true,
				depthWrite: true,
				dithering: false,				
				
				// phong material
				specular: '#444444',				
				shininess: 160.0,
				reflectivity: 0.8,
				
				ka: 0.17,
				kd: 0.51,
				ks: 0.2,
				metallic: true,
				
				hue: 0.121,
				saturation: 0.73,
				lightness: 0.66,
				
				// for light
				lhue: 0.04,
				lsaturation: 0.01, // non-zero so that fractions will be shown
				llightness: 1.0,
				
				// pt
				pt2: pointLight2.color.getHex(),
				pt3: pointLight3.color.getHex(),
				pt4: pointLight4.color.getHex(),
				
				//
				lx: 0.32,
				ly: 0.39,
				lz: 0.7,
				
			};
			  gui.add(option, "side", ["front", "back", "right", "left", "top", "bottom"]).onFinishChange((val)=>{
				  app.updateCameraType(camera, val, fov);
				  app.renderFrame();
			  });
			  
			  let updateFrame = function updateFrame() {
				  app.renderFrame();  
			  };
			  
			  let  f = gui.addFolder('Scene');
			  function handleColorChange(color) {
				  return function(value) {
					  if (typeof value === 'string') {
						  value = value.replace('#', '0x');
					  }
					  color.setHex(value);
				  }
			  }
			  let bkColor = new THREE.Color(), colorConvert = handleColorChange(bkColor);			  
			  f.addColor(option, 'background').name('background').onChange((val)=>{
				  colorConvert(val);
				  renderer.setClearColor(bkColor.getHex());
				  app.renderFrame();
			  });
			  scene.background = bkColor;
			  let toAmbientColor = handleColorChange(ambientLight.color);
			  f.addColor(option, 'ambient').name('ambient').onChange((val)=>{
				  toAmbientColor(val);
				  app.renderFrame();
			  });
			  f.add(option, 'hasFog').name('use fog').onChange((val)=>{
				  if (val) scene.fog = fog;
				  else scene.fog = null;
				  headMaterial.needsUpdate = true;
				  gumMaterial.needsUpdate = true;				  
				  app.renderFrame();
			  });
			  let toFogColor = handleColorChange(fog.color);
			  f.addColor(option, 'fog').name('fog').onChange((val)=>{
				  toFogColor(val);
				  app.renderFrame();
			  })
			  f = gui.addFolder('Mesh Material');
			  f.add(option, 'transparent').onChange((val)=>{
				  headMaterial.transparent = val;
				  gumMaterial.transparent = val;
				  app.renderFrame();
			  });
			  f.add(option, 'opacity', 0, 1).step(0.01).onChange((val)=>{
				  headMaterial.opacity = val;
				  gumMaterial.opacity = val;
				  app.renderFrame();
			  });
			  
			  f = gui.addFolder('Phong Material');
			  gumMaterial.shininess = option.shininess;
			  f.add(option, "shininess", 1.0, 400.0, 1.0).name('shininess').onChange((val)=>{
				  	headMaterial.shininess = val;
					gumMaterial.shininess = val;
					app.renderFrame();
			  });
			  let toSpecularColor = handleColorChange(specularColor);
			  f.addColor(option, 'specular').name('specular').onChange((val)=>{
				  toSpecularColor(val);
				  headMaterial.specular.copy(specularColor);
	 			  gumMaterial.specular.copy(specularColor);
				  app.renderFrame();
			  });
			  f.add(option, "reflectivity", 0, 1.0).name('reflectivity').onChange((val)=>{
				  	headMaterial.reflectivity = val;
					gumMaterial.reflectivity = val;
					app.renderFrame();
			  });
// 			  f = gui.addFolder('Material Control');
			  			  			  
// 			  f.add(option, "shininess", 1.0, 400.0, 1.0).name('shininess').onChange(updateFrame);
// 			  f.add(option, "kd", 0.0, 1.0, 0.025).name('diffuse').onChange(updateFrame);
// 			  f.add(option, "ks", 0.0, 1.0, 0.025).name('specular').onChange(updateFrame);
// 			  f.add(option, "metallic").onChange(updateFrame);
			  
// 			  f = gui.addFolder('Material Color');
// 			  f.add(option, "hue", 0.0, 1.0, 0.025).name('hue').onChange(updateFrame);
// 			  f.add(option, "saturation", 0.0, 1.0, 0.025).name('saturation').onChange(updateFrame);
// 			  f.add(option, "lightness", 0.0, 1.0, 0.025).name('lightness').onChange(updateFrame);
			  
			  f = gui.addFolder('Lighting');
			  f.add(option, 'lhue', 0.0, 1.0, 0.025).name('hue').onChange(updateFrame);
			  f.add(option, 'lsaturation', 0.0, 1.0, 0.025).name('saturation').onChange(updateFrame);
			  f.add(option, 'llightness', 0.0, 1.0, 0.025).name('lightness').onChange(updateFrame);
			  f.add(option, 'ka', 0.0, 1.0, 0.025).name('ambient lighting').onChange(updateFrame);
			
			  let toPt2Color = handleColorChange(pointLight2.color),
			  toPt3Color = handleColorChange(pointLight3.color),
			  toPt4Color = handleColorChange(pointLight4.color);
			  f.addColor(option, 'pt2').name('point light2').onChange((val)=>{
				  toPt2Color(val);
				  app.renderFrame();
			  })
// 			  f.addColor(option, 'pt3').name('point light3').onChange((val)=>{
// 				  toPt3Color(val);
// 				  app.renderFrame();
// 			  })
// 			  f.addColor(option, 'pt4').name('point light4').onChange((val)=>{
// 				  toPt3Color(val);
// 				  app.renderFrame();
// 			  })
			  
// 			  f = gui.addFolder('directionLight Positoin');
// 			  f.add(option, 'lx', -35.0, 35.0, 0.02).name('x').onChange(updateFrame);
// 			  f.add(option, 'ly', -30.0, 30.0, 0.02).name('y').onChange(updateFrame);
// 			  f.add(option, 'lz', -15.0, 15.0, 0.02).name('z').onChange(updateFrame);
			  
			  app.animateHandle.add(()=>{
// 				mesh.rotation.x += 0.01;  
				
			  });
			 
			app.renderCallback((delta)=>{
				
// 				pointLight1.position.copy(camera.position);
// 				pointLight1.updateMatrix();
// 				pointLight1.updateMatrixWorld();
				
				diffuseColor.multiplyScalar(option.kd);
				//headMaterial.color.copy(diffuseColor);
				//gumMaterial.color.copy(diffuseColor);
				
// 				specularColor.multiplyScalar(option.ks);
// 				headMaterial.specular.copy(specularColor);
// 				gumMaterial.specular.copy(specularColor);
				
				//ambientLight.color.setHSL(option.hue, option.saturation, option.lightness * option.ka);
// 				directionLight.position.set(option.lx, option.ly, option.lz);
// 				directionLight.color.setHSL(option.lhue, option.lsaturation, option.llightness);
				
// 				pointLight1.position.set(option.lx, option.ly, option.lz);
				pointLight1.color.setHSL(option.lhue, option.lsaturation, option.llightness);
								
				renderer.render(scene, camera);
			  
			}, ()=>{
				app.updateSize(app.fullWidth, app.fullHeight);
			});			
			
			app.controlUpdate();
			app.renderLoop();
		});
    </script>        
</body>
</html>
